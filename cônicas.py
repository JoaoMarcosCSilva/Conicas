# -*- coding: utf-8 -*-
"""Cônicas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZBLYywUNwCTdeLzUwxBUa0ybkF2HI3FY
"""

import numpy as np
import matplotlib.pyplot as plt

def parse(txt):
    txt = txt.replace('\\', '')
    txt = txt.replace('yx', 'xy')
    txt = txt.replace('^2', '2')
    txt = txt.replace('^{2}', '2')
    txt = txt.replace('-', ' - ')
    txt = txt.replace('=', ' = ')
    txt = txt.replace('+', ' + ')
    txt = txt.replace('  ', ' ')
    txt = txt.replace('   ', ' ')
    
    l = txt.split()

    after_equal = False
    next_neg = False

    conic = {
            'x2': 0.0,
            'y2': 0.0,
            'xy': 0.0,
            'x': 0.0,
            'y': 0.0,
            '': 0.0}
    
    keys = ['=','+', '-', 'x2', 'y2', 'xy', 'x', 'y', '']

    for i in l:
        for key in keys:
            if key in i:
                if key == '=':
                    after_equal = not after_equal
                elif key == '-':
                    next_neg = not next_neg
                elif key == '+':
                    pass
                else:
                    try:
                        val = float(i.replace(key, ''))
                    except:
                        val = 1

                    if after_equal:
                        val *= -1
                    if next_neg:
                        val *= -1
                        next_neg = False
                    conic[key] += val
                break

    A = np.array([[conic['x2'], conic['xy']/2],[conic['xy']/2, conic['y2']]])
    J = np.array([[conic['x']],[conic['y']]])
    H = conic['']
    
    return conic, A, J, H

conic, A, J, H = parse(input("Escreva a equação: "))

epsilon = 1e-10

def classify(A, J, H):

    complete_matrix = np.array([
        [A[0][0], A[0][1], J[0][0]/2],
        [A[1][0], A[1][1], J[1][0]/2],
        [J[0][0]/2, J[1][0]/2, H]
    ])

    complete_det = np.linalg.det(complete_matrix)

    det = np.linalg.det(A)

    txt = ''
    
    if det < -epsilon:
        txt += 'hipérbole'
    elif  np.abs(det) < epsilon:
        txt += 'parábola'
    else:
        txt += 'elipse'

    if complete_det == 0:
        txt += ' degenerada'
        
    return txt

print("A cônica é uma ", classify(A, J, H))

def translate_basis(A, J, H):

    if 'parábola' in classify(A, J, H):
      return np.zeros_like(J), H, J
    else:
      translation = (1/2) * np.matmul(np.linalg.inv(A), J)

      new_H = - np.dot(J.transpose(), translation) / 2 + H
      new_J = np.zeros_like(J)
      return -translation, new_H, new_J


translation, new_H, new_J = translate_basis(A, J, H)

def rotate_basis(A, J):
    
    val, vec = np.linalg.eig(A)
    
    for i, v in enumerate(val):
      if np.abs(v) < epsilon:
        val[i] = 0

    for i, v in enumerate(vec):
      vec[i] = v/np.linalg.norm(v)
    
    

    

    if (val[0] * val[1] < 0 and val[0] < val[1]) or (val[0] * val[1] > 0 and val[0] > val[1]) or (val[0] == 0):
      inverting_matrix = np.array([[0, -1],[1, 0]])
      val = val[::-1]
      vec = np.matmul(inverting_matrix, vec)
      
    
    new_J = np.matmul(vec, J)

    rotation = vec
    new_A = np.diag(val)
    

    return rotation, new_A, new_J

rotation, new_A, new_J = rotate_basis(A, new_J)

def plot(delta, x_range, y_range, resolution, conic, color = 'black'):
  plt.axhline(0, alpha=.1)
  plt.axvline(0, alpha=.1)

  x = np.linspace(-x_range, x_range, resolution)
  y = np.linspace(-y_range, y_range, resolution)
  x, y = np.meshgrid(x,y)
  
  evaluate = 0
  evaluate += x*x*conic['x2']
  evaluate += x*conic['x']
  evaluate += y*y*conic['y2']
  evaluate += y*conic['y']
  evaluate += x*y*conic['xy']
  evaluate += conic['']
  
  plt.axis('equal')
  plt.contour(x, y, evaluate, [0], colors = color)

delta = 4e-1
width = 8
res = 500

if 'parábola' in classify(A, J, H):
    new_J[0] *= 0
    new_H *= 0
    new_A[0][0] = np.abs(new_A[0][0])
    new_J[1][0] = -np.abs(new_J[1][0])

new_conic = {
    'x2': new_A[0][0],
    'y2': new_A[1][1],
    'x': new_J[0],
    'y': new_J[1],
    'xy': new_A[1][0]*2,
    '': new_H
}



plt.subplot(1,2,1)
plt.title('Cônica original')
plot(delta, width, width, res, conic)

def plot_line(a, b, c):
    line_conic = {
        'x2': 0,
        'y2': 0,
        'x': a,
        'y': b,
        'xy': 0,
        '': c
    }

    plot(delta, width, width, res, line_conic, 'orange')

def get_original (rotation, translation, x):
  return np.matmul(rotation, x) + translation

def plot_point (ponto, cor):
    plt.plot(ponto[0], ponto[1], cor + 'o')

def get_parabola(new_A, new_H):
    plt.subplot(1,2,2)
    centro = np.array([0, 0]).reshape(-1,1)
    foco = np.array([0, -1/(4*new_J[1][0]*new_A[0][0])]).reshape(-1,1)

    plot_point(centro, 'b')
    plot_point(foco, 'r')
    plot_line(0, 1, -1/(4*new_J[1][0]*new_A[0][0]))

def get_ellipse_or_hyperbola_data(rotation, translation, new_A, new_H):
  print("")
  print("Equação Padrão: %fx^2 + %fy^2 = 1" % (-new_A[0][0]/new_H,-new_A[1][1]/new_H))
  print("")
  a = float(np.sqrt(np.abs(new_H/(new_A[0][0]))))
  b = float(np.sqrt(np.abs(new_H/(new_A[1][1]))))

  signal = new_A[1][1]/abs(new_A[1][1])
  c = float(np.sqrt(a*a - signal*b*b))
  
  
  
  focus_1 = np.array([c, 0]).reshape(-1,1)
  focus_2 = np.array([-c, 0]).reshape(-1,1)

  focus_1 = get_original(rotation, translation, focus_1)
  focus_2 = get_original(rotation, translation, focus_2)

  print("Focos")
  print(tuple(focus_1.reshape(2)))
  print(tuple(focus_2.reshape(2)))
  plot_point(tuple(focus_1.reshape(2)), 'r')
  plot_point(tuple(focus_2.reshape(2)), 'r')

  print("")
  print("Centro")
  print(tuple(translation.reshape(2)))
  plot_point(tuple(translation.reshape(2)), 'b')

  print("")
  print("Vértices do eixo maior:")
  v1 = np.array([a, 0]).reshape(-1,1)
  v2 = np.array([-a, 0]).reshape(-1,1)
  v1 = get_original(rotation, translation, v1)
  v2 = get_original(rotation, translation, v2)

  print(tuple(v1.reshape(2)))
  print(tuple(v2.reshape(2)))
  plot_point(tuple(v1.reshape(2)), 'g')
  plot_point(tuple(v2.reshape(2)), 'g')

  print("")
  print("Vértices do eixo menor:")
  v1 = np.array([0, b]).reshape(-1,1)
  v2 = np.array([0, -b]).reshape(-1,1)
  v1 = get_original(rotation, translation, v1)
  v2 = get_original(rotation, translation, v2)
  print("")
  print(tuple(v1.reshape(2)))
  print(tuple(v2.reshape(2)))
  plot_point(tuple(v1.reshape(2)), 'g')
  plot_point(tuple(v2.reshape(2)), 'g')

  print("")
  print("Assintotas")

  center = translation.reshape(2)

  reta1 = (get_original(rotation, translation, np.array([a/b, 1]).reshape(-1,1)) - translation).reshape(2)
  reta2 = (get_original(rotation, translation, np.array([a/b, -1]).reshape(-1,1)) - translation).reshape(2)
  
  if 'hipérbole' in classify(A, J, H):

    a = reta1[1]
    b = -reta1[0]
    c = center[1]*reta1[0] - center[0]*reta1[1]
    plot_line(a,b,c)
    print("%fx + %fy + %f = 0" % (a,b,c))
    
    a = reta2[1]
    b = -reta2[0]
    c = center[1]*reta2[0] - center[0]*reta2[1]
    plot_line(a,b,c)
    print("%fx + %fy + %f = 0" % (a,b,c))
  
if 'parábola' not in classify(A, J, H):
  get_ellipse_or_hyperbola_data(rotation, translation, new_A, new_H)

if 'parábola' in classify(A, J, H):
    get_parabola(new_A, new_J)

plt.subplot(1,2,2)
plt.title('Cônica na posição padrão')
plot(delta, width, width, res, new_conic)

plt.show()